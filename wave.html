<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    
    <style>
        body {
            margin: 0;
            animation: gradientBackground 10s infinite alternate;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        @keyframes gradientBackground {
            0% {
                background: linear-gradient(45deg, #f06, #9f6);
            }
            25% {
                background: linear-gradient(45deg, #9f6, #f06);
            }
            50% {
                background: linear-gradient(45deg, #f60, #6f9);
            }
            75% {
                background: linear-gradient(45deg, #6f9, #f60);
            }
            100% {
                background: linear-gradient(45deg, #f06, #9f6);
            }
        }
    </style>
</head>

<body>
    <script>
        let scene, camera, renderer, particleGeometry, torus, particleMesh, time = 0;
        let posArray, colorArray;

        function setup() {
            noCanvas();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Particle System
            const particleCount = 10000;
            posArray = new Float32Array(particleCount * 3);
            colorArray = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                posArray[i] = (Math.random() - 0.5) * 25;
                posArray[i + 1] = (Math.random() - 0.5) * 25;
                posArray[i + 2] = (Math.random() - 0.5) * 25;

                colorArray[i] = colorArray[i + 1] = colorArray[i + 2] = Math.abs(noise(posArray[i], posArray[i + 1], posArray[i + 2]));
            }

            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: THREE.VertexColors
            });

            particleMesh = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleMesh);

            const geometry = new THREE.TorusGeometry(4, 0.5, 200, 5000);

            const shaderMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1.0); 
                    }
                `,
                wireframe: true
            });
            torus = new THREE.Mesh(geometry, shaderMaterial);
            scene.add(torus);

            camera.position.z = 10;

            animate();
        }

        function animate() {
            time += 0.01;

            torus.rotation.x += 0.005;
            torus.rotation.y += 0.005;

            for (let i = 0; i < posArray.length; i += 3) {
                posArray[i + 1] = 5 * Math.sin(posArray[i] + time);
            }
            particleGeometry.attributes.position.needsUpdate = true;

            // Add color variation over time
            for (let i = 0; i < colorArray.length; i += 3) {
                colorArray[i] = Math.abs(Math.sin(time + i));
                colorArray[i + 1] = Math.abs(Math.sin(time + i + 1));
                colorArray[i + 2] = Math.abs(Math.sin(time + i + 2));
            }
            particleGeometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>